#include "LibBMP.h"
#include <stdio.h>

#define ITERS 20
#define XFOV 90
#define YFOV 90
#define pi 3.141592653589
#define ANTIALIASFACTOR 5


/*
THIS SCRIPT IS A RAYCASTING ENGINE. THE IMAGE IT PRODUCES IS
CONSTRUCTED PURELY FROM SUCH RAYCASTING AND RAYTRACING TECHNIQUES
AND IS NOT HARD PROGRAMMED IN ANY WAY. 

THE ONLY OTHER ASSET USED IS A STL FILE USED FOR THE BACKGROUND GEOMETRY,
IT ONLY CONTAINS VERTICES IN 3D SPACE CORRESPONDING TO POLYGONS. THIS IS
IMPLEMENTED AS AN ARRAY IN THE FORM OF HEXADECIMAL TO COMPRESS IT

THE BACKGROUND RHOMBICOSIDODECAHEDRON IS A RENDITION OF THE STL FILE

THE SPHERES, POLYGONS, AND PLANES ARE GENERATED USING A COMBINATION
OF LINEAR ALGEBRA AND 3D ANALYTICAL GEOMETRY

THE ENGINE HAS BEEN GENERALISED TO EASILY ADD AND MODIFY PRIMATIVES
HOWEVER THIS WILL REQUIRE A LITTLE BIT OF KNOWLEDGE ABOUT THE VARIABLES
I.E ENTITYCOUNT AND INITILISARION ARRAYS.

MORE EXTENSIVELY

ITERS - NUMBER OF ITERATIONS TO COMPUTE FOR THE MANDELBROT SET

XFOV, YFOX - X AND Y FIELD OF VIEW IN DEGREES

sphereEntityCount - NUMBER OF SPHERES
sphereEntities[N] - ARRAY OF SPHERES, CHANGE N
sphereAttributes[N][12] - ARRAY OF ATTRIBUTES, POPULATE VALUES

quadEntityCount - NUMBER OF QUADS
quadEntities[N] - ARRAY OF QUADS, CHANGE N
quadAttributes[N][18] - ARRAY OF ATTRIBUTES, POPULATE VALUES

polygonEntityCount - NUMBER OF POLYGONS (MODIFYING WILL BE HARDER AS ITS CONFIGURED TO THE STL)
polygonEntities[N] - ARRAY OF POLYGONS (MODIFYING WILL BE HARDER AS ITS CONFIGURED TO THE STL)

reflectionCount - NUMBER OF TIMES A RAY REFLECTS BEFORE TERMINATING
pixelCols[N][4] - CHANGE N TO reflectionCount TO STORE VALUES FOR RAY REFLECTIONS

ANTIALIASFACTOR - X AND Y ANTIALIAS PER PIXEL. WARNING, THIS WILL SIGNIFICANTLY REDUCE RENDER TIME
                  A FACTOR OF 1 RENDERS IN AROUND 1 MINUTE, 5 AROUND 20 MINUTES


MODIFYING THESE VALUES WILL CHANGE THE PRIMATIVES IN THE SCENE ACCORDINGLY

NOTE : DEPENDING ON THE VARIABLES, NOTABLY ANTIALIASFACTOR, THIS SCRIPT
       MAY TAKE A WHILE TO LOAD, AS IT IS A RAYCASTING ENGINE.
       AN ANTIALIASING FACTOR OF 1 MAY TAKE AROUND 1 MINUTE
       AN ANTIALIASING FACTOR OF 5 MAY TAKE AROUND 20 MINUTES
       AN ANTIALIASING FACTOR GREATER THAN 5, OR reflectionCount
       GREATER THAN 5 IS NOT RECOMMENDED, AS IT WILL TAKE A LONG TIME
       TO RUN AND THE DIFFERENCE WILL BE NEGLIGIBLE

ENJOY!

AUTHOR : JACK FREETH (jfre479)
*/
unsigned char rhombicosidodecahedronSTL[5884] = { //unfortunately as this is an upload submission, i couldnt read the contents of an STL (used for the exterior shell shape encapsulating the scene), so i pasted it here
	// Offset 0x00000000 to 0x00005883
	0x54, 0x68, 0x69, 0x73, 0x20, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79, 0x20, 0x53, 0x54, 0x4C, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x68, 0x6F, 0x6D, 0x62, 0x69, 0x63, 0x6F, 0x73, 0x69, 0x64, 0x6F, 0x64, 0x65, 0x63, 0x61, 0x68, 0x65, 0x64, 0x72, 0x6F, 0x6E, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x5E, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x37, 0xC4, 0x59, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x5E, 0x96, 0x06, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x37, 0xC4, 0x59, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x5E, 0x96, 0x06, 0x3F,
	0x00, 0x00, 0x00, 0x00, 0x37, 0xC4, 0x59, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x5E, 0x96, 0x06, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x37, 0xC4, 0x59, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0x3F, 0x59, 0x96, 0x06, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0xE2, 0x25, 0x6F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B,
	0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0xB6, 0x1B, 0x4F, 0x3F, 0x5D, 0x37, 0x9E, 0x3E, 0x13, 0x00, 0x00, 0x3F, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x09, 0x00, 0x00, 0x3F, 0xBA, 0x1B, 0x4F, 0x3F, 0x6A, 0x37, 0x9E, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x69, 0x37, 0x9E, 0x3E, 0x09, 0x00, 0x00, 0x3F, 0xBA, 0x1B, 0x4F, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x5C, 0x96, 0x06, 0x3F, 0x20, 0x4F, 0x08, 0xB5, 0x3A, 0xC4, 0x59, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0xC1, 0x1B, 0x4F, 0x3F, 0x56, 0x37, 0x9E, 0x3E, 0x06, 0x00, 0x00, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x00, 0x00, 0x3B, 0xCD, 0x13, 0x3F, 0x3A, 0xCD, 0x13, 0x3F, 0x3A, 0xCD, 0x13, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12,
	0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x49, 0x37, 0x9E, 0x3E, 0x0E, 0x00, 0x00, 0x3F, 0xBC, 0x1B, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0x3E, 0xE2, 0x25, 0x6F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xC4, 0x59, 0x3F, 0x66, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x49, 0x37, 0x9E, 0xBE, 0x0E, 0x00, 0x00, 0x3F, 0xBC, 0x1B, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x3F, 0xBC, 0x1B, 0x4F, 0x3F, 0x49, 0x37, 0x9E, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x00, 0x00, 0x38, 0xC4, 0x59, 0x3F, 0x5C, 0x96, 0x06, 0x3F, 0x20, 0x4F, 0x08, 0xB5, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65,
	0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0x3E, 0xE2, 0x25, 0x6F, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0x3F, 0x59, 0x96, 0x06, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x12, 0x00, 0x00, 0x3F, 0xB7, 0x1B, 0x4F, 0x3F, 0x5D, 0x37, 0x9E, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x06, 0x00, 0x00, 0x3F, 0xC1, 0x1B, 0x4F, 0x3F, 0x56, 0x37, 0x9E, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xC4, 0x59, 0x3F, 0x60, 0x96, 0x06, 0x3F, 0xBE, 0x7C, 0xA8, 0x34, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x5C, 0x96, 0x06, 0x3F, 0x20, 0x4F,
	0x08, 0x35, 0x3A, 0xC4, 0x59, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x69, 0x37, 0x9E, 0x3E, 0x09, 0x00, 0x00, 0xBF, 0xBA, 0x1B, 0x4F, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0xBD, 0x1B, 0x4F, 0x3F, 0x4A, 0x37, 0x9E, 0xBE, 0x0F, 0x00, 0x00, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x49, 0x37, 0x9E, 0x3E, 0x0E, 0x00, 0x00, 0x3F, 0xBC, 0x1B, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0x3E, 0xE2, 0x25, 0x6F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x49, 0x37, 0x9E, 0xBE, 0x0E, 0x00, 0x00, 0x3F, 0xBC, 0x1B, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F,
	0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xC4, 0x59, 0x3F, 0x66, 0x96, 0x06, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3B, 0xC4, 0x59, 0x3F, 0x5A, 0x96, 0x06, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0xB7, 0x1B, 0x4F, 0x3F, 0x5D, 0x37, 0x9E, 0x3E, 0x12, 0x00, 0x00, 0xBF, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0x3F, 0x5A, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x80, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F,
	0x91, 0x80, 0xB9, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x09, 0x00, 0x00, 0xBF, 0xBA, 0x1B, 0x4F, 0x3F, 0x6A, 0x37, 0x9E, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x69, 0x37, 0x9E, 0x3E, 0x09, 0x00, 0x00, 0x3F, 0xBA, 0x1B, 0x4F, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x5C, 0x96, 0x06, 0x3F, 0x20, 0x4F, 0x08, 0xB5, 0x3A, 0xC4, 0x59, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x3B, 0xCD, 0x13, 0x3F, 0x3A, 0xCD, 0x13, 0x3F, 0x3A, 0xCD, 0x13, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x00, 0x00, 0xC1, 0x1B, 0x4F, 0x3F, 0x56, 0x37, 0x9E, 0x3E, 0x06, 0x00, 0x00, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0x3F, 0x5A, 0x96, 0x06, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F,
	0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x37, 0xC4, 0x59, 0x3F, 0x5E, 0x96, 0x06, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x25, 0x6F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x09, 0x00, 0x00, 0xBF, 0xBA, 0x1B, 0x4F, 0x3F, 0x6A, 0x37, 0x9E, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x5C, 0x96, 0x06, 0x3F, 0x20, 0x4F, 0x08, 0x35,
	0x3A, 0xC4, 0x59, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0xBD, 0x1B, 0x4F, 0x3F, 0x4A, 0x37, 0x9E, 0xBE, 0x0F, 0x00, 0x00, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x69, 0x37, 0x9E, 0x3E, 0x09, 0x00, 0x00, 0xBF, 0xBA, 0x1B, 0x4F, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0xBF, 0x59, 0x96, 0x06, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x12, 0x00, 0x00, 0x3F, 0xB7, 0x1B, 0x4F, 0xBF, 0x5D, 0x37, 0x9E, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0xBF, 0x59, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80,
	0xB9, 0xBE, 0x00, 0x00, 0xB7, 0x1B, 0x4F, 0xBF, 0x5D, 0x37, 0x9E, 0x3E, 0x12, 0x00, 0x00, 0x3F, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x00, 0x00, 0xBA, 0x1B, 0x4F, 0x3F, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0x3F, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x00, 0x00, 0x3A, 0xCD, 0x13, 0x3F, 0x3B, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0x3F, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x06, 0x00, 0x00, 0x3F, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xC4, 0x59, 0x3F, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0xB5, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0x3E, 0x06, 0x00, 0x00, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80,
	0xB9, 0x3E, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0x3F, 0xBA, 0x1B, 0x4F, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x3B, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0x3F, 0x3A, 0xCD, 0x13, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0x3F, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x00, 0x00, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0xB5, 0x3A, 0xC4, 0x59, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x49, 0x37, 0x9E, 0xBE, 0x0E, 0x00, 0x00, 0xBF, 0xBC, 0x1B, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x49, 0x37, 0x9E, 0x3E, 0x0E, 0x00, 0x00, 0xBF, 0xBC, 0x1B, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xC4, 0x59, 0xBF, 0x66, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65,
	0x4F, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0xBE, 0xE2, 0x25, 0x6F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0x0E, 0x00, 0x00, 0xBF, 0xBC, 0x1B, 0x4F, 0x3F, 0x49, 0x37, 0x9E, 0xBE, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x00, 0x00, 0x0E, 0x00, 0x00, 0xBF, 0xBC, 0x1B, 0x4F, 0x3F, 0x49, 0x37, 0x9E, 0x3E, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x33, 0xC4, 0x59, 0xBF, 0x66, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0x3E, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0xBE, 0xE2, 0x25, 0x6F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x12, 0x00, 0x00, 0x3F, 0xB7, 0x1B, 0x4F, 0xBF, 0x5D, 0x37,
	0x9E, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0x3E, 0xE2, 0x25, 0x6F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0xBF, 0x59, 0x96, 0x06, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0xE2, 0x25, 0x6F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x3A, 0xCD, 0x13, 0x3F, 0x3B, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0xBF, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x3F, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0xBA, 0x1B, 0x4F, 0x3F, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0xBF, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x3A, 0xC4, 0x59, 0x3F, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0x35, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0xF9, 0x12, 0x16, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0x35, 0x3A, 0xC4, 0x59, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0xBF, 0xBA, 0x1B, 0x4F, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0x3F, 0x00, 0x00, 0xBD, 0x1B, 0x4F, 0xBF, 0x4A, 0x37, 0x9E, 0xBE, 0x0F, 0x00, 0x00, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0x3F,
	0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x49, 0x37, 0x9E, 0xBE, 0x0E, 0x00, 0x00, 0xBF, 0xBC, 0x1B, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x49, 0x37, 0x9E, 0x3E, 0x0E, 0x00, 0x00, 0xBF, 0xBC, 0x1B, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xC4, 0x59, 0xBF, 0x66, 0x96, 0x06, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0xBE, 0xE2, 0x25, 0x6F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x37, 0xC4, 0x59, 0xBF, 0x5E, 0x96, 0x06, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0xBF, 0x5A, 0x96, 0x06, 0x3F, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E,
	0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x12, 0x00, 0x00, 0xBF, 0xB7, 0x1B, 0x4F, 0xBF, 0x5D, 0x37, 0x9E, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0xE2, 0x25, 0x6F, 0xBF, 0x00, 0x00, 0x00, 0x80, 0x94, 0xB1, 0xB6, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0xB7, 0x1B, 0x4F, 0xBF, 0x5D, 0x37, 0x9E, 0x3E, 0x12, 0x00, 0x00, 0xBF, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0xBF, 0x5A, 0x96, 0x06, 0x3F, 0x00, 0x00, 0x00, 0x00,
	0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x06, 0x4B, 0x65, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x00, 0x00, 0xBA, 0x1B, 0x4F, 0xBF, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0x3F, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x3A, 0xCD, 0x13, 0xBF, 0x3B, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0x3F, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0x00, 0x00, 0x3A, 0xC4, 0x59, 0xBF, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0xB5, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xBF, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x00, 0x00, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0x3F, 0xBA, 0x1B, 0x4F, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00,
	0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0xB5, 0x3A, 0xC4, 0x59, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0x3E, 0x06, 0x00, 0x00, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x00, 0x00, 0x3B, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0x3F, 0x3A, 0xCD, 0x13, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0x3E, 0x80, 0x80, 0x39, 0xBF, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0x3F, 0x91, 0x80, 0xB9, 0xBE, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0x3F, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xC4, 0x59, 0xBF, 0x5A, 0x96, 0x06, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0x12, 0x00, 0x00, 0xBF, 0xB7, 0x1B, 0x4F, 0xBF, 0x5D, 0x37, 0x9E, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0x3E, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B,
	0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0x00, 0x00, 0x94, 0xB1, 0xB6, 0xBE, 0xE2, 0x25, 0x6F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0x3E, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6, 0x1B, 0x4F, 0xBF, 0x5D, 0x37, 0x9E, 0xBE, 0x13, 0x00, 0x00, 0xBF, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x06, 0x00, 0x00, 0xBF, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xC4, 0x59, 0xBF, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0x35, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0xF9, 0x12, 0x16, 0xBF, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x41, 0xD3, 0x72, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x00, 0x00, 0xC1, 0x1B, 0x4F, 0xBF, 0x56, 0x37, 0x9E, 0xBE, 0x06, 0x00, 0x00, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0xBA, 0x65, 0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00, 0x5C, 0x96, 0x06, 0xBF, 0x20, 0x4F, 0x08, 0x35, 0x3A, 0xC4, 0x59, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xBA, 0x65,
    0x4F, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x12, 0x16, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x00, 0x00, 0x3B, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0xBF, 0x3A, 0xCD, 0x13, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x00, 0x00, 0x69, 0x37, 0x9E, 0xBE, 0x09, 0x00, 0x00, 0xBF, 0xBA, 0x1B, 0x4F, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0x06, 0x4B, 0x65, 0xBE, 0x06, 0x4B, 0x65, 0xBE, 0x41, 0xD3, 0x72, 0xBF, 0x91, 0x80, 0xB9, 0xBE, 0x80, 0x80, 0x39, 0xBF, 0xF9, 0x12, 0x16, 0xBF, 0x00, 0x00
};

unsigned int rhombicosidodecahedronBin[116][3][3][32];

typedef union {
 
    float f;
    struct
    {
        unsigned int mantissa : 23;
        unsigned int exponent : 8;
        unsigned int sign : 1;
    } raw;
} real32;

typedef struct Vec3 { // 3D Raycast Vector
    double x,y,z; // Vector Components
} Vec3;

typedef struct Sphere { // Sphere;
    double r; //Radius
    Vec3 pos; //Center position

    double kd; // diffuse coeffecient
    double ka; // ambient coeffecient
    double kr; // absorbtion coeffecient (1 purely opaque)
    double ks; // shiny coeffecient ( >0 shiny)
    double n; // highlighting factor
    double R,G,B; //surface colour
} Sphere;

typedef struct QuadSurface { // Quad Surface
    Vec3 p1,p2,p3,p4; // Clockwise from P1, AS THE FIRST 3 POINTS DEFINE THE PLANE, IT IS ASSUMED 4TH IS COLINEAR
    double kd; // diffuse coeffecient
    double ka; // ambient coeffecient
    double kr; // absorbtion coeffecient (1 purely opaque)
    double ks; // shiny coeffecient ( >0 shiny)
    double n; // highlighting factor
    double c1[3]; // starting RGB colour
    double c2[3]; // ending RGB colour
} QuadSurface;

typedef struct Polygon {
    Vec3 p1,p2,p3;
    double kd; // diffuse coeffecient
    double ka; // ambient coeffecient
    double kr; // absorbtion coeffecient (1 purely opaque)
    double ks; // shiny coeffecient ( >0 shiny)
    double n; // highlighting factor
    double R,G,B; //surface colour
} Polygon;

int XRES;
int YRES;
Vec3 camPos;
Vec3 camRot;
Vec3 origin;
Vec3 cameraNormal;

Sphere s1; // Sphere
QuadSurface MBSPlane; // Mandelbrot Plane
Vec3 L1; // Light Source

Polygon Poly1;

Sphere sphereEntities[4]; //Entity array decleration
QuadSurface quadEntities[2];
Polygon polyEntities[116];

int sphereEntityCount = 4; //Entity type count 
int quadEntityCount = 2;
int polyEntityCount = 116;

double sphereAttributes[4][12] = {
    {0.5,0,0,-1.5,0.4,0.6,0.75,0.4,4,20,50,200}, // r, pos.x, pos.y, pos.z, ka, kd, kr, ks, n, R, G, B
    {0.4,-1,0.3,-1.7,0.4,0.6,0.75,0.4,4,20,200,50},
    {0.7,2,0.5,-2.3,0.2,0.8,0.75,0.8,7,200,30,50},
    {0.3,0.2,0.6,-1,0.4,0.6,0.75,0.4,4,224,176,255}
};

double planeAttributes[2][18] = { // p1.x, p1.y, p1.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z, p4.x, p4.y, p4.z,
    
    /*
    CONVERT LAST 6 VARIABLES TO 

    8,242,0,117,74,10
    0,255,255,255,110,199

    TO HAVE A GREEN,BROWN / CYAN,PINK COLOUR SCHEME
    */
    
    {-2,-1,-3,2,-1,-3,2,-1,1,-2,-1,1,255,0,0,255,255,0},           
    {-2,1.3,-3,2,1.3,-3,2,1.3,1,-2,1.3,1,0,0,255,0,255,255}
};

double abss(double x){ //absolute function abs(x)
    return x>=0 ? x : x*-1;
}

double maxOfThree(double a, double b, double c){ //largest of 3 values
    return a > b ? ( a > c ? a : c) : ( b > c ? b : c);
}

double minOfThree(double a, double b, double c){ //smallest of 3 values
    return a < b ? ( a < c ? a : c) : ( b < c ? b : c);
}

double poww(double base, int exp){ // only supported for integer exponents, as the scope of this project only requires this
    double baseTemp = exp > 0 ? base : 1/base;
    for(int i = 1; i<abss(exp);i++){
        base*=baseTemp;
    }
    return exp == 0 ? 1 : base;
}

double square(double x){ //x^2 function
    return poww(x,2);
}

double sqrt(double x){ //square root function
    float sq = x/2;
    float temp = 0;
    while(sq != temp){
        temp = sq;
        sq = (x/temp + temp)/2;
    }
    return sq;
}

int quadratic(double a, double b, double c, double t[2]){ // ax^2 + bx + c = 0, with roots t[2]. returns number of roots
    double disc = square(b)-4*a*c;
    if(disc < 0){
        return 0;
    }else{
        t[0] = (-b - sqrt(disc))/(2*a);
        t[1] = (-b + sqrt(disc))/(2*a);
        return disc == 0 ? 1:2;
    }
}

unsigned int convertBinToFloat(int* arr, int low, int high){ //assist in the conversion of binary to a float

    unsigned v = 0;
    for (int i = high; i >= low; i--) {
        v = v + arr[i] * poww(2, high - i);
    }
    return v;
}

int factorial(int x){ //factorial function x!
    if(x<=0){
        return x;
    }else{
        int buffer = x-1;
        while(buffer > 0){
            x*=buffer;
            buffer--;
        }
        return x;
    }
}

int factorialfactorial(int x){ //double factorial function x!!
    if(x<=0){
        return x;
    }else{
        int buffer = x-2;
        while(buffer > 0){
            x*=buffer;
            buffer-=2;
        }
        return x;
    }
}

double rad(double theta){ // Degrees to Radians
    return theta*pi/180;
}

double sin(double x){ //Sin Taylor Series Expansion
    while(abss(x) > 2*pi){
        x += x > 0 ? -2*pi : 2*pi;
    }
    if(abss(x) > pi){
        x = pi + x > 0 ? -x : x;
    }
    return x - poww(x,3)/factorial(3) + poww(x,5)/factorial(5) - poww(x,7)/factorial(7) + poww(x,9)/factorial(9) - poww(x,11)/factorial(11);
}

double cos(double x){ //Cos Taylor Series Expansion
    while(abss(x) > 2*pi){
        x += x > 0 ? -2*pi : 2*pi;
    }
    if(abss(x) > pi){
        x = pi + x > 0 ? -x : x;
    }
    return 1 - poww(x,2)/factorial(2) + poww(x,4)/factorial(4) - poww(x,6)/factorial(6) + poww(x,8)/factorial(8) - poww(x,10)/factorial(10);
}

double acos(double x){ //arccos function as a taylor series
    return pi/2 - x - poww(x,3)/factorial(3) - 3*poww(x,5)/factorial(5) - factorialfactorial(5)*poww(x,7)/factorial(7) - factorialfactorial(7)*poww(x,9)/factorial(9);
}

double tan(double x){ //tangent function 
    return sin(x)/cos(x);
}

void vectorAddition(Vec3 v1, Vec3 v2, Vec3 *v3){ // Addition of 2 3Vecs
    v3->x = v1.x + v2.x;
    v3->y = v1.y + v2.y;
    v3->z = v1.z + v2.z;
}

void vectorSubtraction(Vec3 v1, Vec3 v2, Vec3 *v3){ // Subtraction of 2 3Vecs
    v3->x = v1.x - v2.x;
    v3->y = v1.y - v2.y;
    v3->z = v1.z - v2.z;
}

void vectorMultiplication(double m, Vec3 *a){ //scalar vector multiplication
    a->x = a->x*m;
    a->y = a->y*m;
    a->z = a->z*m;
}

double lengthVec3(Vec3 a){ //length of a vector
    return sqrt(square(a.x) + square(a.y) + square(a.z));
}

double dot(Vec3 a, Vec3 b){ //dot product
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

void cross(Vec3 a, Vec3 b, Vec3 *c){ //cross product
    c->x = a.y*b.z - a.z*b.y;
    c->y = a.z*b.x - a.x*b.z;
    c->z = a.x*b.y - a.y*b.x;
}

double det(double a, double b, double c, double d){ // 2x2 determinent
    return a*d-c*b;
}

void vec3MatrixMultiplication(Vec3 v1, double m1[3][3], Vec3 *v2){ // Matrix multiplication of a 3x3 and a Vec3
    v2->x = v1.x*m1[0][0] + v1.y*m1[0][1] + v1.z*m1[0][2];
    v2->y = v1.x*m1[1][0] + v1.y*m1[1][1] + v1.z*m1[1][2];
    v2->z = v1.x*m1[2][0] + v1.y*m1[2][1] + v1.z*m1[2][2];
}

// Translate a point in 3D space to a rotated frame of reference
void rotatedPointFrameOfReference(Vec3 a, Vec3 c, double taitBryanMatrices[3][3][3], Vec3 *d){
    Vec3 D;
    vectorSubtraction(a,c,&D);
    vec3MatrixMultiplication(D,taitBryanMatrices[2], d);
    D = *d;
    vec3MatrixMultiplication(D,taitBryanMatrices[1], d);
    D = *d;
    vec3MatrixMultiplication(D,taitBryanMatrices[0], d);
    
    d->x=D.x;
    d->y=D.y;
    d->z=D.z; 

}

int mandelBrotIteration(double xPoint, double yPoint){ // Compute diverging iteration of Mandelbrot(x,y)
    double xFunc = xPoint;
    double yFunc = yPoint;
    double tempXFunc;
    for(int i = 0; i < ITERS; i++){ //recursive function
        if(square(xFunc) + square(yFunc) >= 4.0){
            return i;
        }
        tempXFunc = xFunc;
        xFunc = square(xFunc) - square(yFunc) + xPoint;
        yFunc = 2*tempXFunc*yFunc + yPoint;
    }
    return -1;
}

void planeNormal(QuadSurface q, Vec3 *N){ //normal vector to a plane defined by 3 points
    Vec3 p1p2; 
    Vec3 p1p3;
    vectorSubtraction(q.p2,q.p1,&p1p2);
    vectorSubtraction(q.p3,q.p1,&p1p3);
    cross(p1p2,p1p3,N);
}

void polyNormal(Polygon P, Vec3 *N){ //normal vector to a polygon defined by 3 points
    Vec3 p1p2; 
    Vec3 p1p3;
    vectorSubtraction(P.p2,P.p1,&p1p2);
    vectorSubtraction(P.p3,P.p1,&p1p3);
    cross(p1p2,p1p3,N);
}

int linePlaneIntersection(Vec3 v, Vec3 o, QuadSurface q, Vec3 *p, double *t){ // Point p, where Vector v about o intercepts plane p1,p2,p3 defined by q, after t vectors v. Returns number of first roots
    
   
    Vec3 normal;
    double d;

    planeNormal(q,&normal);
    
    d = -(normal.x*q.p1.x + normal.y*q.p1.y + normal.z*q.p1.z);

    double planeCoeffecients[4] = {
        normal.x,
        normal.y,
        normal.z,
        d
    };

    if((normal.x*v.x + normal.y*v.y + normal.z*v.z) == 0){ //no root exists
        return 0;
    }else{ //root exists
        *t=-(normal.x*o.x + normal.y*o.y + normal.z*o.z + d)/(normal.x*v.x + normal.y*v.y + normal.z*v.z);
        if(*t > 0 || *t <=0){ 
            p->x = o.x + v.x*(*t);
            p->y = o.y + v.y*(*t); 
            p->z = o.z + v.z*(*t);
            return *t > 0 ? 1:0; //if root exists in line of sight of vector
        }  
    }

    
    
}



int lineSphereIntersection(Vec3 v, Vec3 o, Sphere S, Vec3 *p, double *t){ // first root p, where Vector v about o intercepts sphere S, after t vectors v. Returns number of first roots
    //the roots of the line sphere intercept is the solution of a quadratic

    double a,b,c,roots[2]; 

    a = square(v.x) + square(v.y) + square(v.z);
    b = -2*((v.x)*(S.pos.x-o.x) + (v.y)*(S.pos.y-o.y) + (v.z)*(S.pos.z-o.z));           // Quadratic with such coeffecients
    c = square(S.pos.x-o.x) + square(S.pos.y-o.y) + square(S.pos.z-o.z) - square(S.r);  // Ax^2 + Bx + C = 0

    if(quadratic(a,b,c,roots) > 0){ //line intercepts
        if(roots[0] > 0 || roots[1] > 0){ //line intercepts infront of origin
            if(roots[0] > 0 && roots[1] > 0){
                *t = roots[0] < roots[1] ? roots[0] : roots[1];
            }else{
                *t = roots[0] > 0 ? roots[0] : roots[1];
            }
            vectorMultiplication(*t,&v);
            vectorAddition(v,o,p);
            return 1;
        }else{ //line intercepts behind origin, we dont care about this
            return 0;
        }
    } else { //line doesnt intercept
        return 0;
    }

}

void normaliseVector(Vec3 *v){ // same direction, length 1
    double length = lengthVec3(*v);
    vectorMultiplication(1/length,v);
}

void reflection(Vec3 v, Vec3 n, Vec3 *r){ //calculates a reflected vector given an incoming vector and a normal vector
    normaliseVector(&n);
    vectorMultiplication(2*dot(v,n),&n);
    vectorSubtraction(v,n,r);
};


void PlanarInterceptToRelativeCoordinated(QuadSurface p, Vec3 i, double uv[2]){
    /*
    Computing the relative intercept coordinates u,v of a plane p, with a centroid origin and U,V P2-P1,P2-P3
    of a point i
    
    let o.x , o.y , o.z be the origin of the plane in 3d
    let u.x , u.y , u.z be the 3d vector representing the 2d unit vector u of the plane as seen from the plane origin
    let v.x , v.y , v.z be the 3d vector representing the 2d unit vector v of the plane as seen from the plane origin
    let i.x , i.y , i.z be the intercept of the line and plane
    */

    Vec3 o; 
    Vec3 u;
    Vec3 v;

    o.x = (p.p1.x + p.p2.x + p.p3.x + p.p4.x)/4.0;
    o.y = (p.p1.y + p.p2.y + p.p3.y + p.p4.y)/4.0;
    o.z = (p.p1.z + p.p2.z + p.p3.z + p.p4.z)/4.0;

    vectorSubtraction(p.p2,p.p1,&u);
    vectorSubtraction(p.p2,p.p3,&v);
    
    vectorMultiplication(0.25,&u);
    vectorMultiplication(0.25,&v);
    
    vectorSubtraction(i,o,&i);

    double divisors[3] = {u.x*v.y-v.x*u.y,u.x*v.z-v.x*u.z,u.y*v.z-v.y*u.z};

    if (maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[0])){ //change of coordinate systems x axis, using the demoninator of the greatest magnitude for numerical stability
        uv[0] = (i.x*v.y - i.y*v.x)/divisors[0];
    } else if(maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[1])){
        uv[0] = (i.x*v.z - i.z*v.x)/divisors[1];
    } else {
        uv[0] = (i.y*v.z - i.z*v.y)/divisors[2];
    }
    
    if (maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[0])){ //change of coordinate systems y axis, using the demoninator of the greatest magnitude for numerical stability
        uv[1] = (i.y*u.x - i.x*u.y)/divisors[0];
    } else if(maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[1])){
        uv[1] = (i.z*u.x - i.x*u.z)/divisors[1];
    } else {
        uv[1] = (i.z*u.y - i.y*u.z)/divisors[2];
    }

}

void PolyInterceptToRelativeCoordinated(Polygon P, Vec3 i, double uv[2]){
    /*
    Computing the relative intercept coordinates u,v of a plane p, with a centroid origin and U,V P2-P1,P2-P3
    of a point i
    
    let o.x , o.y , o.z be the origin of the plane in 3d
    let u.x , u.y , u.z be the 3d vector representing the 2d unit vector u of the plane as seen from the plane origin
    let v.x , v.y , v.z be the 3d vector representing the 2d unit vector v of the plane as seen from the plane origin
    let i.x , i.y , i.z be the intercept of the line and plane
    */

    Vec3 o; 
    Vec3 u;
    Vec3 v;

    o.x = P.p1.x;
    o.y = P.p1.y;
    o.z = P.p1.z;

    vectorSubtraction(P.p2,P.p1,&u);
    vectorSubtraction(P.p3,P.p1,&v);
    
    vectorSubtraction(i,o,&i);

    double divisors[3] = {u.x*v.y-v.x*u.y,u.x*v.z-v.x*u.z,u.y*v.z-v.y*u.z};

    if (maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[0])){ //change of coordinate systems x axis, using the demoninator of the greatest magnitude for numerical stability
        uv[0] = (i.x*v.y - i.y*v.x)/divisors[0];
    } else if(maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[1])){
        uv[0] = (i.x*v.z - i.z*v.x)/divisors[1];
    } else {
        uv[0] = (i.y*v.z - i.z*v.y)/divisors[2];
    }
    
    if (maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[0])){ //change of coordinate systems y axis, using the demoninator of the greatest magnitude for numerical stability
        uv[1] = (i.y*u.x - i.x*u.y)/divisors[0];
    } else if(maxOfThree(abss(divisors[0]),abss(divisors[1]),abss(divisors[2])) == abss(divisors[1])){
        uv[1] = (i.z*u.x - i.x*u.z)/divisors[1];
    } else {
        uv[1] = (i.z*u.y - i.y*u.z)/divisors[2];
    }

}

int linePolyIntersection(Vec3 v, Vec3 o, Polygon P, Vec3 *p, double *t){ // Point p, where Vector v about o intercepts polygon P, after t vectors v. Returns number of first root if exists within poly bounds on plane
    
   
    Vec3 normal;
    double d;

    polyNormal(P,&normal);
    
    d = -(normal.x*P.p1.x + normal.y*P.p1.y + normal.z*P.p1.z); //constant

    double planeCoeffecients[4] = { //format plane as Ax + By + Cz + D = 0
        normal.x,
        normal.y,
        normal.z,
        d
    };

    if((normal.x*v.x + normal.y*v.y + normal.z*v.z) == 0){ //no root exists
        return 0;
    }else{ //root exists
        *t=-(normal.x*o.x + normal.y*o.y + normal.z*o.z + d)/(normal.x*v.x + normal.y*v.y + normal.z*v.z);
        if(*t > 0 || *t <=0){ 
            p->x = o.x + v.x*(*t);
            p->y = o.y + v.y*(*t); 
            p->z = o.z + v.z*(*t);
            if(*t > 0){ // Polygon is in line of sight of vector
                double uv[2];
                PolyInterceptToRelativeCoordinated(P,*p,uv);
                if(uv[0] > 0 && uv[1] > 0 && (uv[0] + uv[1]) <= 1){ // forms a triangle in the relative coordinate system
                    return 1;
                }else{
                    return 0;
                }
            }else{
                return 0;
            }
        }  
    }

    
    
}

void pointColour(Vec3 rayCast, double RGB[3]){ // Render Pixel (x,y)
    Vec3 rayOrigin;
    rayOrigin.x = origin.x;
    rayOrigin.y = origin.y;
    rayOrigin.z = origin.z;

    int reflectionCount = 0;
    double terminate = 0; //set 1 if ray doesnt intercept with anymore entities, conclude the ray reflection loop
    double pixelCols[5][4]; // First dimension reflection count, second dimension R,B,G,Weight of the pixel 

    for(int R = 0; R<5; R++){
        if(reflectionCount == 5){
            terminate = 1;
        }
        if(terminate == 0){
            normaliseVector(&rayCast);
            Vec3 planarPoint; //point of intersection of line and plane
            Vec3 spherePoint; //point of intersection of line and sphere
            int closestQuadEntity = -1;
            int closestSphereEntity = -1; //element of Entity array which is the closest eligible entity of its type from the ray
            int closestPolyEntity = -1;
            double closestQuadDistance = 9999;
            double closestSphereDistance = 9999; //distance from the closest entity from the ray
            double closestPolyDistance = 9999;
            
            double t1,t2; //unit vectors to intercept, i.e the distance
            
        
            for(int Q = 0; Q<quadEntityCount; Q++){ //finding the closest quad
                int intersects = linePlaneIntersection(rayCast, rayOrigin, quadEntities[Q], &planarPoint, &t1);
                if(intersects == 1){
                    double uv[2];
                    PlanarInterceptToRelativeCoordinated(quadEntities[Q], planarPoint, uv);
                    if((abss(uv[0]) < 2 && abss(uv[1]) < 2) && t1 < closestQuadDistance){
                        closestQuadDistance = t1;
                        closestQuadEntity = Q;
                    }
                }
                
            }

            for(int P = 0; P<polyEntityCount; P++){ //finding the closest Polygon
                int intersects = linePolyIntersection(rayCast, rayOrigin, polyEntities[P], &planarPoint, &t1);
                if(intersects == 1 && t1> 0.0001){ //0.0001 to mitigate the problem of a reflection colliding with the plane its originating from
                    closestPolyDistance = t1;
                    closestPolyEntity = P;
                }
                
            }

            for(int S = 0; S<sphereEntityCount; S++){ //finding the closest Sphere
                int intersects = lineSphereIntersection(rayCast, rayOrigin, sphereEntities[S], &spherePoint, &t2);
                if(intersects == 1 && t2 < closestSphereDistance && t2> 0.0001){ //0.0001 to mitigate the problem of a reflection colliding with the plane its originating from
                    closestSphereDistance = t2;
                    closestSphereEntity = S;
                }
            }
            
            if((minOfThree(closestPolyDistance,closestQuadDistance,closestSphereDistance) == closestQuadDistance) && closestQuadEntity != -1){ //render quad colour

                double uv[2];
                int inShadow = 0;

                linePlaneIntersection(rayCast, rayOrigin, quadEntities[closestQuadEntity], &planarPoint, &t1);
                PlanarInterceptToRelativeCoordinated(quadEntities[closestQuadEntity], planarPoint, uv);
                int iteration = mandelBrotIteration(uv[0],uv[1]);
                Vec3 L;
                vectorSubtraction(L1,planarPoint,&L); //vector to the light source

                for(int i = 0; i < sphereEntityCount; i++){
                    
                    if(lineSphereIntersection(L,planarPoint,sphereEntities[i], &spherePoint, &t1) == 1){
                        inShadow = 1;
                    }

                }

                /* DECIDED NOT TO USE POLYGON SHADOWS
                for(int i = 0; i < polyEntityCount; i++){
                    Vec3 polyPoint;
                    if(linePolyIntersection(L,planarPoint,polyEntities[i], &polyPoint, &t1) == 1){
                        //inShadow = 1;
                    }
                    
                }*/

                if(iteration == -1){
                    pixelCols[R][0] = 0;
                    pixelCols[R][1] = 0;
                    pixelCols[R][2] = 0;
                    pixelCols[R][3] = 1;
                }else{
                    /*
                    if(closestQuadEntity == 1){
                        pixelCols[R][2] = 255 / (inShadow == 0 ? 1 : 2);
                        pixelCols[R][1] = iteration*12 / (inShadow == 0 ? 1 : 2);
                        pixelCols[R][0] = iteration*0.5 / (inShadow == 0 ? 1 : 2);
                        
                    }else{
                        pixelCols[R][0] = 255 / (inShadow == 0 ? 1 : 2);
                        pixelCols[R][1] = iteration*12 / (inShadow == 0 ? 1 : 2);
                        pixelCols[R][2] = iteration*0.5 / (inShadow == 0 ? 1 : 2);
                    }*/
                    double sc[3] = {quadEntities[closestQuadEntity].c1[0],quadEntities[closestQuadEntity].c1[1],quadEntities[closestQuadEntity].c1[2]}; //temporary variable starting colour to store q.c1[x]
                    double ec[3] = {quadEntities[closestQuadEntity].c2[0],quadEntities[closestQuadEntity].c2[1],quadEntities[closestQuadEntity].c2[2]}; //temporary variable starting colour to store q.c2[x], for readability
                    double cf = poww((double)(ITERS-iteration)/ITERS,3); //exponential color factor towards the final colour
                    pixelCols[R][0] = (sc[0] < ec[0] ? ec[0] - abss(ec[0]-sc[0])*cf : ec[0] + abss(ec[0]-sc[0])*cf) / (inShadow == 0 ? 1 : 2);
                    pixelCols[R][1] = (sc[1] < ec[1] ? ec[1] - abss(ec[1]-sc[1])*cf : ec[1] + abss(ec[1]-sc[1])*cf) / (inShadow == 0 ? 1 : 2);
                    pixelCols[R][2] = (sc[2] < ec[2] ? ec[2] - abss(ec[2]-sc[2])*cf : ec[2] + abss(ec[2]-sc[2])*cf) / (inShadow == 0 ? 1 : 2);
                    pixelCols[R][3] = 1;
                }
                rayOrigin.x = planarPoint.x;
                rayOrigin.y = planarPoint.y;
                rayOrigin.z = planarPoint.z;
                Vec3 N;
                planeNormal(quadEntities[closestQuadEntity], &N);
                reflection(rayCast,N,&rayCast);
            }else if((minOfThree(closestPolyDistance,closestQuadDistance,closestSphereDistance) == closestSphereDistance) && closestSphereEntity != -1){ //render sphere colour
                lineSphereIntersection(rayCast, rayOrigin, sphereEntities[closestSphereEntity], &spherePoint, &t1);
                int inShadow = 0;
                double r,g,b;

                /* DECIDED NOT TO INCLUDE SPHERE SHADOWS
                for(int i = 0; i < sphereEntityCount; i++){
                    Vec3 garbage;
                    Vec3 L;
                    vectorSubtraction(L1,planarPoint,&L);
                    if(lineSphereIntersection(L,spherePoint,sphereEntities[i], &garbage, &t2) == 1){
                        inShadow = 1;
                    }
                }*/

                if(inShadow == 0){
                    Vec3 N; //vector normal to surface of sphere
                    vectorSubtraction(spherePoint,sphereEntities[closestSphereEntity].pos,&N);
                    normaliseVector(&N);
                    Vec3 L; //vector from the surface to the light source 
                    vectorSubtraction(L1,spherePoint,&L);
                    normaliseVector(&L);

                    Vec3 V; //vector from the origin to the surface
                    vectorSubtraction(rayOrigin,spherePoint,&V); 
                    normaliseVector(&V);

                    Vec3 H;
                    vectorAddition(L,V,&H);
                    normaliseVector(&H);

                    double fctr = dot(L,N); //lighting factor = cos angle between U,N = dot U,N after normalised

                    double hf = poww(dot(H,N),sphereEntities[closestSphereEntity].n); //highlighting factor
                    r = sphereEntities[closestSphereEntity].ka * sphereEntities[closestSphereEntity].R + sphereEntities[closestSphereEntity].kd * sphereEntities[closestSphereEntity].R * fctr + sphereEntities[closestSphereEntity].ks * hf * 255; //Blinn Phong Lighting Model
                    g = sphereEntities[closestSphereEntity].ka * sphereEntities[closestSphereEntity].G + sphereEntities[closestSphereEntity].kd * sphereEntities[closestSphereEntity].G * fctr + sphereEntities[closestSphereEntity].ks * hf * 255;
                    b = sphereEntities[closestSphereEntity].ka * sphereEntities[closestSphereEntity].B + sphereEntities[closestSphereEntity].kd * sphereEntities[closestSphereEntity].B * fctr + sphereEntities[closestSphereEntity].ks * hf * 255;
                    rayOrigin.x = spherePoint.x;
                    rayOrigin.y = spherePoint.y;
                    rayOrigin.z = spherePoint.z;
                    reflection(rayCast,N,&rayCast);
                }else{
                    r = sphereEntities[closestSphereEntity].ka * sphereEntities[closestSphereEntity].R;
                    g = sphereEntities[closestSphereEntity].ka * sphereEntities[closestSphereEntity].G;
                    b = sphereEntities[closestSphereEntity].ka * sphereEntities[closestSphereEntity].B;
                }
                pixelCols[R][0] = r;
                pixelCols[R][1] = g;
                pixelCols[R][2] = b;
                pixelCols[R][3] = sphereEntities[closestSphereEntity].kr;
                
                //Vec3 N;
                //vectorSubtraction(sphereEntities[closestSphereEntity].pos,spherePoint,&N);
                
            }else if((minOfThree(closestPolyDistance,closestQuadDistance,closestSphereDistance) == closestPolyDistance) && closestPolyEntity != -1){
                
                int inShadow = 0;
                double r,g,b;
                Vec3 polyPoint;
                linePolyIntersection(rayCast, rayOrigin, polyEntities[closestPolyEntity], &polyPoint, &t1);
                Vec3 L; //vector from the surface to the light source 
                vectorSubtraction(L1,polyPoint,&L);
                normaliseVector(&L);
                

                /* DECIDED NOT TO INCLUDE POLYGON SHADOWS
                for(int i = 0; i < sphereEntityCount; i++){
                    if(lineSphereIntersection(L,polyPoint,sphereEntities[i], &spherePoint, &t1) == 1){
                        inShadow = 1;
                    }
                }
    
                for(int i = 0; i < polyEntityCount; i++){
                    Vec3 polyPoint;
                    if(linePolyIntersection(L,planarPoint,polyEntities[i], &polyPoint, &t1) == 1){
                        //inShadow = 1;
                    }
                    
                }*/
                
                Vec3 N; //vector normal to surface
                polyNormal(polyEntities[closestPolyEntity],&N);
                normaliseVector(&N);
                
                Vec3 V; //vector from the origin to the surface
                vectorSubtraction(rayOrigin,polyPoint,&V); 
                normaliseVector(&V);
                Vec3 H;
                vectorAddition(L,V,&H);
                normaliseVector(&H);
                double fctr = dot(L,N); //lighting factor = cos angle between U,N = dot U,N after normalised
                double hf = poww(dot(H,N),polyEntities[closestPolyEntity].n); //highlighting factor

                r = polyEntities[closestPolyEntity].ka * polyEntities[closestPolyEntity].R + polyEntities[closestPolyEntity].kd * polyEntities[closestPolyEntity].R * fctr + polyEntities[closestPolyEntity].ks * hf * 255; //Blinn Phong Lighting Model
                g = polyEntities[closestPolyEntity].ka * polyEntities[closestPolyEntity].G + polyEntities[closestPolyEntity].kd * polyEntities[closestPolyEntity].G * fctr + polyEntities[closestPolyEntity].ks * hf * 255;
                b = polyEntities[closestPolyEntity].ka * polyEntities[closestPolyEntity].B + polyEntities[closestPolyEntity].kd * polyEntities[closestPolyEntity].B * fctr + polyEntities[closestPolyEntity].ks * hf * 255;
                rayOrigin.x = planarPoint.x;
                rayOrigin.y = planarPoint.y;
                rayOrigin.z = planarPoint.z;
                reflection(rayCast,N,&rayCast);
                pixelCols[R][0] = r;
                pixelCols[R][1] = g;
                pixelCols[R][2] = b;
                pixelCols[R][3] = 1;
                terminate = 1;
            }else{
                pixelCols[R][0] = 235;
                pixelCols[R][1] = 235;
                pixelCols[R][2] = 235;
                pixelCols[R][3] = 1;
                terminate = 1;
            }
        }
        reflectionCount++;

    }

    double remainingWeight[3] = {1,1,1}; //weight of pixel reflection remaining
    double r = 0;
    double g = 0;
    double b = 0;
    for(int i = 0; i< reflectionCount; i++){ //weighting reflections
        r += pixelCols[i][0]*pixelCols[i][3]*remainingWeight[0];
        remainingWeight[0] = remainingWeight[0]-pixelCols[i][3]*remainingWeight[0];
        g += pixelCols[i][1]*pixelCols[i][3]*remainingWeight[1];
        remainingWeight[1] = remainingWeight[1]-pixelCols[i][3]*remainingWeight[1];
        b += pixelCols[i][2]*pixelCols[i][3]*remainingWeight[2];
        remainingWeight[2] = remainingWeight[2]-pixelCols[i][3]*remainingWeight[2];
    }
    RGB[0] = r;
    RGB[1] = g;
    RGB[2] = b;
    
}

void renderScreen(void){ // Render plane
    for(int i = 0; i < XRES; i++){
        for(int j = 0; j < YRES; j++){ //for every pixel
            Vec3 rayCast;
            double RGBRay[3] = {0,0,0};
            double RGBPixel[3] = {0,0,0};
            for(int k = 0; k < ANTIALIASFACTOR; k++){
                for(int l = 0; l < ANTIALIASFACTOR; l++){ //anti alias each pixel by a factor of ANTIALIASFACTOR^2 across x,y
                    
                    rayCast.z = cameraNormal.z;
                    rayCast.x = tan(rad(XFOV/2.0))*(2.0*(i + k*1.0/(1.0*ANTIALIASFACTOR))/XRES + cameraNormal.z);
                    rayCast.y = -tan(rad(YFOV/2.0))*(2.0*(j + l*1.0/(1.0*ANTIALIASFACTOR))/YRES + cameraNormal.z);
                    pointColour(rayCast,RGBRay);
                    RGBPixel[0] += RGBRay[0]/square(ANTIALIASFACTOR); //add ray and weight to pixel colour
                    RGBPixel[1] += RGBRay[1]/square(ANTIALIASFACTOR);
                    RGBPixel[2] += RGBRay[2]/square(ANTIALIASFACTOR);
                }
            }
            DrawPixel(j,i,RGBPixel[0],RGBPixel[1],RGBPixel[2]);
            
            
            
        }
    }
}


void init(void){

    camPos.x = 0;
    camPos.y = 0;
    camPos.z = 1;

    camRot.x = -0.3;
    camRot.y = 0;
    camRot.z = 0.45;

    double rollPitchYawMatrices[3][3][3] = { // Rotation Matrices inspired by Tait-Bryan Rotations
        {
            {1,              0,             0},
            {0,  cos(camRot.x), sin(camRot.x)},
            {0, -sin(camRot.x), cos(camRot.x)}
        },{
            {cos(camRot.y), 0, -sin(camRot.y)},
            {0,             1,              0},
            {sin(camRot.y), 0,  cos(camRot.y)}
        },{
            { cos(camRot.z), sin(camRot.z), 0},
            {-sin(camRot.z), cos(camRot.z), 0},
            {             0,             0, 1}
        }
    };

    cameraNormal.x = 0.0;
    cameraNormal.y = 0.0;
    cameraNormal.z = -1.0;

    origin.x = 0;
    origin.y = 0;
    origin.z = 0;

    L1.x = 2;
    L1.y = 1;
    L1.z = -1;

    for(int i = 0; i < quadEntityCount; i++){
        quadEntities[i] = MBSPlane;
        
        quadEntities[i].p1.x = planeAttributes[i][0];
        quadEntities[i].p1.y = planeAttributes[i][1];
        quadEntities[i].p1.z = planeAttributes[i][2];

        quadEntities[i].p2.x = planeAttributes[i][3];
        quadEntities[i].p2.y = planeAttributes[i][4];
        quadEntities[i].p2.z = planeAttributes[i][5];

        quadEntities[i].p3.x = planeAttributes[i][6];
        quadEntities[i].p3.y = planeAttributes[i][7];
        quadEntities[i].p3.z = planeAttributes[i][8];

        quadEntities[i].p4.x = planeAttributes[i][9];
        quadEntities[i].p4.y = planeAttributes[i][10];
        quadEntities[i].p4.z = planeAttributes[i][11];

        quadEntities[i].c1[0] = planeAttributes[i][12];
        quadEntities[i].c1[1] = planeAttributes[i][13];
        quadEntities[i].c1[2] = planeAttributes[i][14];

        quadEntities[i].c2[0] = planeAttributes[i][15];
        quadEntities[i].c2[1] = planeAttributes[i][16];
        quadEntities[i].c2[2] = planeAttributes[i][17];

        rotatedPointFrameOfReference(quadEntities[i].p1, camPos, rollPitchYawMatrices, &quadEntities[i].p1);
        rotatedPointFrameOfReference(quadEntities[i].p2, camPos, rollPitchYawMatrices, &quadEntities[i].p2);
        rotatedPointFrameOfReference(quadEntities[i].p3, camPos, rollPitchYawMatrices, &quadEntities[i].p3);
        rotatedPointFrameOfReference(quadEntities[i].p4, camPos, rollPitchYawMatrices, &quadEntities[i].p4);

    }

    for(int i = 0; i < sphereEntityCount; i++){
        sphereEntities[i] = s1;
        
        sphereEntities[i].r = sphereAttributes[i][0];
        sphereEntities[i].pos.x = sphereAttributes[i][1];
        sphereEntities[i].pos.y = sphereAttributes[i][2];

        sphereEntities[i].pos.z = sphereAttributes[i][3];
        sphereEntities[i].ka = sphereAttributes[i][4];
        sphereEntities[i].kd = sphereAttributes[i][5];

        sphereEntities[i].kr = sphereAttributes[i][6];
        sphereEntities[i].ks = sphereAttributes[i][7];
        sphereEntities[i].n = sphereAttributes[i][8];

        sphereEntities[i].R = sphereAttributes[i][9];
        sphereEntities[i].G = sphereAttributes[i][10];
        sphereEntities[i].B = sphereAttributes[i][11];

        rotatedPointFrameOfReference(sphereEntities[i].pos, camPos, rollPitchYawMatrices, &sphereEntities[i].pos);


    }
    

    for(int i = 0; i < 116; i++){
        polyEntities[0] = Poly1;
    }
    
    int byteBuffer = 84; //skip the header and information in the STL
    


    //converting the STL file format into a binary file compatible with this engine
    for(int i = 0; i < 116; i++){ //for every 116 polygons
        byteBuffer+=12;
        for(int points = 0; points<3; points++){ //for every 3 points of a polygon   
            for(int vector = 0; vector < 3; vector++){ // for every 3 values representing a vector
                for(int j = 3; j>=0; j--){ // for every 4 bytes representing an IEEE754
                    int bitSize = 0;
                    int bits[8];
                    int input = rhombicosidodecahedronSTL[byteBuffer];
                    for(int k = 7; k>=0; k--){ //8 bits per byte
                        rhombicosidodecahedronBin[i][points][vector][8*j+k] = input%2; //conversion of the hexdumped STL into binary
                        input/=2;
                    }
                    byteBuffer++;
                    
                }
            }
        }
        byteBuffer+=2;
    }

    
    for(int i = 0; i < 116; i++){  // initialising the rhombicosidodecahedron polygon array from the binary array
        float points[9];
        for(int j = 0; j<3;j++){
            for(int k = 0;k<3;k++){
                real32 var;
                unsigned f = convertBinToFloat(rhombicosidodecahedronBin[i][j][k], 9, 31); //aquiring float mantissa from 32 bit binary representation
                var.raw.mantissa = f;
                f = convertBinToFloat(rhombicosidodecahedronBin[i][j][k], 1, 8); //aquiring float exponent
                var.raw.exponent = f;
                var.raw.sign = rhombicosidodecahedronBin[i][j][k][0]; //aquiring float sign
                points[j*3 + k] = var.f;
            }
        }
        polyEntities[i].p1.x = points[0]*6+0.01; //Scaling polygon and populating in polygon array
        polyEntities[i].p1.y = points[1]*6+0.01;
        polyEntities[i].p1.z = points[2]*6-5;
        polyEntities[i].p3.x = points[3]*6+0.01;
        polyEntities[i].p3.y = points[4]*6+0.01;
        polyEntities[i].p3.z = points[5]*6-5;
        polyEntities[i].p2.x = points[6]*6+0.01;
        polyEntities[i].p2.y = points[7]*6+0.01;
        polyEntities[i].p2.z = points[8]*6-5;

        polyEntities[i].ka = 0.4;
        polyEntities[i].kd = 0.6;
        polyEntities[i].kr = 1;
        polyEntities[i].ks = 0.1;
        polyEntities[i].n = 6;

        polyEntities[i].R = 224;
        polyEntities[i].G = 176;
        polyEntities[i].B = 255;
    }
    
    
}


int main(){
    
    init(); // initialise the primatives
    LoadBMPFile("blank.bmp",&XRES,&YRES); 
    renderScreen();
    SaveBMPFile("blank.bmp",XRES,YRES);
    return 0;
}